# üèóÔ∏è ARQUITECTURA DE SOFTWARE - Multi Ninja Espacial

## üìê Experiencia de Ingenier√≠a y Arquitectura

Este documento captura todas las **decisiones arquitect√≥nicas, patrones de dise√±o, y lecciones de ingenier√≠a de software** aplicadas en este proyecto.

---

## üéØ VISI√ìN ARQUITECT√ìNICA GENERAL

### Principios Fundamentales Aplicados

#### 1. **Separation of Concerns (SoC)**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     PRESENTATION LAYER                       ‚îÇ
‚îÇ  (UI, GameHUD, MainMenu, PauseMenu)                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     GAME LOGIC LAYER                         ‚îÇ
‚îÇ  (GameWorld, Player, NPCs, Interactions)                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     DOMAIN LAYER                             ‚îÇ
‚îÇ  (Enums, Constants, Utils, Systems)                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     DATA LAYER                               ‚îÇ
‚îÇ  (SaveSystem, PlayerData, ChunkManager)                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### 2. **Single Responsibility Principle (SRP)**
Cada clase tiene **una √∫nica raz√≥n para cambiar**:
- `ChunkManager` ‚Üí Solo gestiona chunks
- `TerrainGenerator` ‚Üí Solo genera terreno
- `BiomeSystem` ‚Üí Solo calcula biomas
- `AchievementSystem` ‚Üí Solo gestiona logros

#### 3. **Dependency Inversion Principle (DIP)**
Los m√≥dulos de alto nivel no dependen de m√≥dulos de bajo nivel:
```gdscript
# ‚úÖ CORRECTO: GameWorld depende de abstracci√≥n
class GameWorld:
    var chunk_manager: ChunkManager  # Interfaz/contrato
    var terrain_generator: TerrainGenerator

    func place_block(pos, type):
        chunk_manager.place_block(pos, type)  # No conoce implementaci√≥n

# ‚ùå INCORRECTO: GameWorld conociendo detalles de implementaci√≥n
class GameWorld:
    func place_block(pos, type):
        # Acceso directo a estructuras internas
        var chunk = chunks_dict[chunk_pos]
        chunk.blocks[local_pos] = type
```

#### 4. **Open/Closed Principle (OCP)**
Abierto para extensi√≥n, cerrado para modificaci√≥n:
```gdscript
# Sistema de herramientas extensible sin modificar c√≥digo existente
const TOOL_DATA: Dictionary = {
    ToolType.WOODEN_PICKAXE: { ... },
    ToolType.DIAMOND_PICKAXE: { ... },
    # ‚úÖ Nuevas herramientas se a√±aden sin modificar l√≥gica existente
    ToolType.NEW_SUPER_TOOL: { ... }
}
```

---

## üß© PATRONES DE DISE√ëO IMPLEMENTADOS

### 1. **Singleton Pattern (Autoloads)**

**Problema:** Necesitamos acceso global a sistemas centrales sin pasar referencias por todo el √°rbol.

**Soluci√≥n:** Godot Autoloads (variante de Singleton)

```gdscript
# Configuraci√≥n en project.godot
[autoload]
GameManager="*res://autoloads/GameManager.gd"
PlayerData="*res://autoloads/PlayerData.gd"
AchievementSystem="*res://autoloads/AchievementSystem.gd"

# Uso desde cualquier parte
func on_block_broken():
    AchievementSystem.increment_stat("blocks_broken", 1)
    PlayerData.add_to_inventory(block_type, 1)
```

**Ventajas:**
- ‚úÖ Acceso global sin acoplamiento
- ‚úÖ Una sola instancia garantizada
- ‚úÖ Inicializaci√≥n ordenada por Godot

**Desventajas conocidas:**
- ‚ö†Ô∏è Puede crear dependencias ocultas
- ‚ö†Ô∏è Dificulta testing unitario
- ‚ö†Ô∏è Estado global puede causar bugs sutiles

**Mitigaci√≥n:**
- Usar se√±ales para comunicaci√≥n cuando sea posible
- Mantener autoloads sin estado cuando sea factible
- Documentar dependencias claramente

---

### 2. **Observer Pattern (Signals)**

**Problema:** Componentes necesitan reaccionar a eventos sin conocerse directamente.

**Soluci√≥n:** Sistema de se√±ales de Godot

```gdscript
# Emisor (no conoce a receptores)
class AchievementSystem:
    signal achievement_unlocked(achievement_id, achievement_data)

    func _unlock_achievement(id, data):
        achievement_unlocked.emit(id, data)

# Receptor (se subscribe al evento)
class GameHUD:
    func _ready():
        AchievementSystem.achievement_unlocked.connect(_on_achievement)

    func _on_achievement(id, data):
        show_notification(data.name)
```

**Ventajas:**
- ‚úÖ Desacoplamiento total
- ‚úÖ M√∫ltiples observadores sin modificar emisor
- ‚úÖ F√°cil de extender

**Casos de uso en el proyecto:**
1. `GameManager.scene_changed` ‚Üí UI escucha cambios de escena
2. `AchievementSystem.achievement_unlocked` ‚Üí UI muestra notificaci√≥n
3. `DayNightCycle.time_period_changed` ‚Üí GameWorld ajusta comportamiento
4. `PlayerData.luz_changed` ‚Üí UI actualiza barra

---

### 3. **Factory Pattern (Generaci√≥n Procedural)**

**Problema:** Crear objetos complejos (chunks, estructuras, √°rboles) con l√≥gica variable.

**Soluci√≥n:** Factory methods

```gdscript
# ChunkManager act√∫a como Factory
class ChunkManager:
    func _create_chunk(chunk_pos: Vector3i) -> Chunk:
        var chunk = chunk_scene.instantiate()
        add_child(chunk)  # ORDEN CR√çTICO
        chunk.initialize(chunk_pos)

        # Delegar generaci√≥n al generador especializado
        if terrain_generator:
            terrain_generator.generate_chunk_terrain(chunk)

        return chunk

# StructureGenerator act√∫a como Factory
class StructureGenerator:
    static func try_generate_random_structures(chunk, pos):
        var structure_type = _select_random_structure()
        match structure_type:
            "temple": _generate_templo(chunk, pos)
            "house": _generate_casa(chunk, pos)
            "tower": _generate_torre(chunk, pos)
```

**Ventajas:**
- ‚úÖ Encapsula l√≥gica de creaci√≥n compleja
- ‚úÖ F√°cil a√±adir nuevos tipos sin modificar c√≥digo
- ‚úÖ Centraliza configuraci√≥n

---

### 4. **Strategy Pattern (Herramientas y Habilidades)**

**Problema:** Diferentes herramientas tienen comportamientos diferentes al romper bloques.

**Soluci√≥n:** Strategy pattern con diccionario de comportamientos

```gdscript
class MagicTool:
    const TOOL_DATA: Dictionary = {
        ToolType.WOODEN_PICKAXE: {
            "speed_multiplier": 2.0,
            "special_ability": ""
        },
        ToolType.HAMMER_OF_THUNDER: {
            "speed_multiplier": 5.0,
            "special_ability": "area_break_3x3"
        }
    }

    static func apply_special_ability(tool_type, world, pos, player):
        var ability = TOOL_DATA[tool_type].special_ability
        match ability:
            "area_break_3x3": _break_area_3x3(world, pos)
            "transmute": _transmute_block(world, pos)
            "reality_warp": _reality_warp(world, pos)
```

**Ventajas:**
- ‚úÖ Comportamientos intercambiables
- ‚úÖ F√°cil a√±adir nuevas estrategias
- ‚úÖ Algoritmos encapsulados

---

### 5. **State Pattern (GameManager)**

**Problema:** El juego tiene diferentes estados (MENU, LOADING, PLAYING, PAUSED) con comportamientos distintos.

**Soluci√≥n:** Enum de estados con transiciones controladas

```gdscript
class GameManager:
    enum GameState { MENU, LOADING, PLAYING, PAUSED, GAME_OVER }
    var current_state: GameState = GameState.MENU

    func change_state(new_state: GameState):
        _exit_state(current_state)
        current_state = new_state
        _enter_state(new_state)
        state_changed.emit(new_state)

    func _enter_state(state: GameState):
        match state:
            GameState.PLAYING:
                AudioManager.play_gameplay_music()
                Input.mouse_mode = Input.MOUSE_MODE_CAPTURED
            GameState.PAUSED:
                get_tree().paused = true
```

**Ventajas:**
- ‚úÖ Transiciones expl√≠citas y controladas
- ‚úÖ Comportamiento espec√≠fico por estado
- ‚úÖ F√°cil debugging de flujo

---

### 6. **Data-Driven Design (Configuraci√≥n Externa)**

**Problema:** Balancear juego requiere cambiar constantemente valores num√©ricos.

**Soluci√≥n:** Datos separados de l√≥gica en diccionarios constantes

```gdscript
# ‚úÖ Datos centralizados y f√°ciles de modificar
const BLOCK_HARDNESS: Dictionary = {
    BlockType.TIERRA: 0.5,
    BlockType.PIEDRA: 2.0,
    BlockType.ORO: 4.0
}

const ACHIEVEMENTS: Dictionary = {
    "first_block": {
        "requirement": 1,
        "reward_luz": 5,
        "tier": "bronze"
    }
}

const RECIPES: Dictionary = {
    "diamond_pickaxe": {
        "ingredients": { ORO: 3, CRISTAL: 5 },
        "luz_cost": 100
    }
}
```

**Ventajas:**
- ‚úÖ Cambios de balance sin tocar c√≥digo
- ‚úÖ F√°cil de extender (JSON/CSV en futuro)
- ‚úÖ Dise√±adores pueden modificar sin programar

---

## üèõÔ∏è ARQUITECTURA DE SISTEMAS

### Sistema de Chunks (Spatial Partitioning)

**Problema:** Mundo infinito no puede estar todo en memoria.

**Soluci√≥n:** Chunk-based world con carga/descarga din√°mica

```
Arquitectura de Chunks:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ChunkManager                          ‚îÇ
‚îÇ  - Dictionary<Vector3i, Chunk> chunks                    ‚îÇ
‚îÇ  - Genera chunks seg√∫n posici√≥n del jugador              ‚îÇ
‚îÇ  - Cachea chunks cercanos                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚îÇ gestiona
                 ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                       Chunk                              ‚îÇ
‚îÇ  - Array3D[16][30][16] blocks                           ‚îÇ
‚îÇ  - MeshInstance3D visual_mesh                           ‚îÇ
‚îÇ  - StaticBody3D collision_body                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚îÇ contiene
                 ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ  Individual Block ‚îÇ
        ‚îÇ  (Enums.BlockType)‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Decisiones clave:**
1. **Tama√±o de chunk: 16x30x16**
   - Raz√≥n: Balance entre granularidad y overhead
   - 16x16 XZ ‚Üí M√∫ltiplo com√∫n, f√°cil de indexar
   - 30 Y ‚Üí Altura m√°xima del mundo

2. **Greedy Meshing**
   - Combina caras adyacentes del mismo tipo
   - Reduce tri√°ngulos de 6 caras √ó N bloques a 1 cara √ó √°rea
   - Mejora rendimiento ~90%

3. **Chunk Pooling (futuro)**
   - Reutilizar chunks descargados en lugar de destruir
   - Reduce garbage collection

**Complejidad:**
- Generaci√≥n: O(16 √ó 30 √ó 16) = O(7680) por chunk
- B√∫squeda de bloque: O(1) con hash map
- Mesh generation: O(N) donde N = bloques visibles

---

### Sistema de Generaci√≥n Procedural

**Pipeline de generaci√≥n:**

```
1. Semilla del mundo (seed)
         ‚Üì
2. Perlin Noise (FastNoiseLite)
         ‚Üì
3. BiomeSystem.get_biome_at(x, z)
         ‚Üì
4. TerrainGenerator.generate_chunk_terrain()
         ‚Üì
5. StructureGenerator.try_generate_structures()
         ‚Üì
6. Chunk.generate_mesh()
         ‚Üì
7. Chunk visible en el mundo
```

**Algoritmos utilizados:**

#### Perlin Noise
```gdscript
noise = FastNoiseLite.new()
noise.seed = world_seed
noise.noise_type = FastNoiseLite.TYPE_PERLIN
noise.frequency = 0.05

# Valor entre -1.0 y 1.0
var noise_value = noise.get_noise_2d(world_x, world_z)
var normalized = (noise_value + 1.0) / 2.0  # 0.0 a 1.0

# Mapear a altura
var height = int(lerp(min_height, max_height, normalized))
```

**Caracter√≠sticas:**
- ‚úÖ Determin√≠stico (misma semilla = mismo mundo)
- ‚úÖ Continuo (sin discontinuidades bruscas)
- ‚úÖ Eficiente (O(1) por coordenada)

#### Bioma Selection (Multi-layer Noise)
```gdscript
# Noise para temperatura
var temp_noise = get_noise_2d(x * 0.003, z * 0.003)

# Noise para humedad
var humidity_noise = get_noise_2d(x * 0.004, z * 0.004)

# Mapeo a bioma
if temp < -0.2: return NIEVE
elif humidity > 0.3: return BOSQUE
elif temp > 0.3: return PLAYA
else: return MONTANAS
```

---

### Sistema de Logros (Achievement System)

**Arquitectura:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              AchievementSystem (Autoload)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Stats: Dictionary<String, float>                     ‚îÇ
‚îÇ    - blocks_placed: 0                                  ‚îÇ
‚îÇ    - blocks_broken: 0                                  ‚îÇ
‚îÇ    - distance_walked: 0.0                              ‚îÇ
‚îÇ                                                        ‚îÇ
‚îÇ  Achievements: Dictionary<String, AchievementData>     ‚îÇ
‚îÇ    - first_block: { requirement: 1, ... }             ‚îÇ
‚îÇ                                                        ‚îÇ
‚îÇ  Unlocked: Array<String>                              ‚îÇ
‚îÇ    - ["first_block", "explorer", ...]                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                           ‚îÇ
         ‚îÇ emit signal               ‚îÇ check unlocks
         ‚ñº                           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  GameHUD         ‚îÇ        ‚îÇ  Player actions  ‚îÇ
‚îÇ  - show_popup    ‚îÇ        ‚îÇ  - place_block() ‚îÇ
‚îÇ  - play_sound    ‚îÇ        ‚îÇ  - break_block() ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Patr√≥n de tracking:**
```gdscript
# 1. Acci√≥n del jugador
func place_block(pos, type):
    world.place_block(pos, type)

    # 2. Incrementar estad√≠stica
    AchievementSystem.increment_stat("blocks_placed", 1)

    # 3. Sistema verifica autom√°ticamente todos los logros
    # 4. Si alguno se desbloquea, emite se√±al
    # 5. UI escucha se√±al y muestra notificaci√≥n
```

**Ventajas arquitect√≥nicas:**
- ‚úÖ Desacoplado de gameplay (no afecta l√≥gica de juego)
- ‚úÖ Extensible (nuevos logros sin modificar c√≥digo)
- ‚úÖ Persistente (se guarda con SaveSystem)

---

### Sistema de Crafteo (Recipe System)

**Arquitectura:**

```
Recipe Structure:
{
    "diamond_pickaxe": {
        "ingredients": { ORO: 3, CRISTAL: 5, METAL: 2 },
        "luz_cost": 100,
        "result": MagicTool.ToolType.DIAMOND_PICKAXE,
        "tier": "legendary"
    }
}

Validation Flow:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ can_craft(id)?  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Check ingredients in inventory ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Check Luz Interior sufficient  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Return true/false              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Crafting Flow:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ craft_item(id)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Consume ingredients            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Consume Luz Interior           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Give result to player          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Increment achievement stat     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Transaction Pattern:**
```gdscript
func craft_item(recipe_id):
    # Validaci√≥n at√≥mica
    if not can_craft(recipe_id):
        return false

    # Transacci√≥n (todo o nada)
    var recipe = RECIPES[recipe_id]

    # Consumir recursos
    for block_type in recipe.ingredients:
        PlayerData.remove_from_inventory(block_type, amount)
    PlayerData.add_luz(-recipe.luz_cost)

    # Dar resultado
    PlayerData.add_tool(recipe.result)

    # Side effects
    AchievementSystem.increment_stat("items_crafted", 1)
    AudioManager.play_sfx(SoundType.MAGIC_CAST)

    return true
```

---

## üîÑ MANEJO DE ESTADO Y CICLO DE VIDA

### Godot Node Lifecycle

**Orden cr√≠tico de inicializaci√≥n:**

```
Engine Start
    ‚Üì
Autoloads _ready() (orden en project.godot)
    ‚Üì
Main Scene _ready()
    ‚Üì
Child Nodes _ready() (top to bottom)
    ‚Üì
_enter_tree() ‚Üí _ready() ‚Üí _process()
```

**Lecci√≥n cr√≠tica aprendida:**
```gdscript
# ‚ùå INCORRECTO
func _create_chunk(pos):
    var chunk = chunk_scene.instantiate()
    chunk.initialize(pos)  # ‚ùå chunk no est√° en √°rbol
    add_child(chunk)

# ‚úÖ CORRECTO
func _create_chunk(pos):
    var chunk = chunk_scene.instantiate()
    add_child(chunk)       # ‚úÖ Primero a√±adir al √°rbol
    chunk.initialize(pos)  # ‚úÖ Luego inicializar
```

**Raz√≥n:** `is_inside_tree()` solo retorna `true` despu√©s de `add_child()`.

---

### Async Operations y Race Conditions

**Problema:** Chunk generation es async, player spawn es s√≠ncrono.

**Soluci√≥n:** Await frames para sincronizaci√≥n

```gdscript
func _ready():
    _generate_world()  # Inicia generaci√≥n

    # ‚úÖ Esperar a que chunks se generen
    await get_tree().process_frame
    await get_tree().process_frame

    _spawn_player()  # Ahora chunks est√°n listos
```

**Por qu√© 2 frames:**
1. Frame 1: ChunkManager crea chunks
2. Frame 2: Chunks generan mesh y colisi√≥n
3. Frame 3: Safe para spawner entities

---

## üé® ARQUITECTURA DE EFECTOS VISUALES

### Particle System Architecture

```
ParticleEffects (Static Class)
    ‚îÇ
    ‚îú‚îÄ Tool Effects
    ‚îÇ   ‚îú‚îÄ create_tool_break_effect()
    ‚îÇ   ‚îú‚îÄ create_tool_glow()
    ‚îÇ   ‚îî‚îÄ create_magic_trail()
    ‚îÇ
    ‚îú‚îÄ Special Ability Effects
    ‚îÇ   ‚îú‚îÄ create_thunder_explosion()
    ‚îÇ   ‚îú‚îÄ create_transmute_effect()
    ‚îÇ   ‚îú‚îÄ create_freeze_effect()
    ‚îÇ   ‚îî‚îÄ create_reality_warp_effect()
    ‚îÇ
    ‚îú‚îÄ Crafting Effects
    ‚îÇ   ‚îî‚îÄ create_craft_success_effect()
    ‚îÇ
    ‚îî‚îÄ Achievement Effects
        ‚îî‚îÄ create_achievement_effect()
```

**Pattern: Self-Cleaning Particles**
```gdscript
static func create_effect(world, position):
    var particles = GPUParticles3D.new()
    particles.one_shot = true
    particles.emitting = true
    world.add_child(particles)

    # ‚úÖ Auto-destruir despu√©s de completar
    await world.get_tree().create_timer(2.0).timeout
    particles.queue_free()
```

**Ventajas:**
- ‚úÖ Sin memory leaks (auto-cleanup)
- ‚úÖ No requiere gesti√≥n manual
- ‚úÖ Performa bien (GPU particles)

---

## üåê ARQUITECTURA DE MUNDO ABIERTO

### Spatial Indexing

**Problema:** Buscar bloques en mundo infinito es O(N).

**Soluci√≥n:** Hash map con coordenadas de chunk

```gdscript
# Convertir posici√≥n de bloque a chunk
func world_to_chunk_position(world_pos: Vector3i) -> Vector3i:
    return Vector3i(
        floori(float(world_pos.x) / CHUNK_SIZE),
        floori(float(world_pos.y) / CHUNK_SIZE),
        floori(float(world_pos.z) / CHUNK_SIZE)
    )

# B√∫squeda O(1)
var chunks: Dictionary = {}  # Dictionary<Vector3i, Chunk>

func get_block(world_pos: Vector3i) -> BlockType:
    var chunk_pos = world_to_chunk_position(world_pos)
    var chunk = chunks.get(chunk_pos)
    if not chunk:
        return BlockType.NONE

    var local_pos = world_pos - chunk_pos * CHUNK_SIZE
    return chunk.get_block(local_pos)
```

**Complejidad:**
- B√∫squeda: O(1) average, O(N) worst case (hash collision)
- Inserci√≥n: O(1)
- Eliminaci√≥n: O(1)

---

### LOD (Level of Detail) - Futuro

**Arquitectura propuesta:**

```
Player Position
    ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Distance-based LOD System            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  0-32m:   Full detail (all blocks)    ‚îÇ
‚îÇ  32-64m:  Medium (simplified mesh)    ‚îÇ
‚îÇ  64-128m: Low (billboard/impostor)    ‚îÇ
‚îÇ  128m+:   Unloaded                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üß™ TESTING Y DEBUGGING

### Debugging Strategies Aplicadas

#### 1. Defensive Programming
```gdscript
# ‚úÖ Siempre validar antes de usar
func get_block(pos: Vector3i) -> BlockType:
    if not is_inside_tree():
        push_warning("Chunk not in tree")
        return BlockType.NONE

    if not _is_valid_position(pos):
        push_warning("Invalid position: ", pos)
        return BlockType.NONE

    return blocks[pos.x][pos.y][pos.z]
```

#### 2. Null Safety
```gdscript
# ‚úÖ Usar get() con default en lugar de []
var chunk = chunks.get(chunk_pos)  # Retorna null si no existe
if chunk:
    chunk.do_something()

# ‚úÖ Verificar referencias antes de usar
if terrain_generator and terrain_generator.has_method("generate"):
    terrain_generator.generate_chunk_terrain(chunk)
```

#### 3. Assertion Pattern
```gdscript
func initialize(chunk_pos: Vector3i):
    assert(is_inside_tree(), "Chunk debe estar en √°rbol antes de inicializar")
    assert(chunk_pos.y >= 0, "Chunk Y debe ser >= 0")
    self.chunk_position = chunk_pos
```

---

## üìä PERFORMANCE Y OPTIMIZACI√ìN

### Memory Management

**Godot Memory Model:**
```
Stack (local variables)
    ‚Üì
Heap (objetos con new())
    ‚Üì
Scene Tree (nodos con add_child())
    ‚Üì
Godot Resource Manager (texturas, meshes)
```

**Estrategias aplicadas:**

#### 1. Object Pooling (concepto)
```gdscript
# Futuro: Pool de chunks para reutilizar
var chunk_pool: Array[Chunk] = []

func get_chunk_from_pool() -> Chunk:
    if chunk_pool.size() > 0:
        return chunk_pool.pop_back()  # Reutilizar
    else:
        return Chunk.new()  # Crear nuevo

func return_chunk_to_pool(chunk: Chunk):
    chunk.clear()
    chunk_pool.append(chunk)
```

#### 2. Lazy Initialization
```gdscript
# ‚úÖ Crear solo cuando se necesita
var _day_night_cycle: DayNightCycle = null

func get_day_night_cycle() -> DayNightCycle:
    if not _day_night_cycle:
        _day_night_cycle = DayNightCycle.new()
        add_child(_day_night_cycle)
    return _day_night_cycle
```

#### 3. Greedy Meshing (Chunk Optimization)
```
Sin optimizaci√≥n:       Con Greedy Meshing:
6 caras √ó 7680 bloques  ~1000 caras (combinadas)
= 46,080 tri√°ngulos     = ~2000 tri√°ngulos
                        90% reducci√≥n! ‚úÖ
```

---

## üîê SEGURIDAD Y VALIDACI√ìN

### Input Validation

```gdscript
# ‚úÖ Validar bounds antes de acceder a arrays
func set_block(pos: Vector3i, type: BlockType):
    if pos.x < 0 or pos.x >= CHUNK_SIZE:
        return false
    if pos.y < 0 or pos.y >= MAX_HEIGHT:
        return false
    if pos.z < 0 or pos.z >= CHUNK_SIZE:
        return false

    blocks[pos.x][pos.y][pos.z] = type
    return true
```

### Safe Resource Loading

```gdscript
# ‚úÖ Verificar que recursos existan
func load_safe(path: String):
    if not FileAccess.file_exists(path):
        push_error("Archivo no encontrado: ", path)
        return null

    var resource = load(path)
    if not resource:
        push_error("No se pudo cargar: ", path)
        return null

    return resource
```

---

## üéì LECCIONES DE ARQUITECTURA

### 1. **Composition over Inheritance**

```gdscript
# ‚ùå EVITAR: Herencia profunda
class Entity extends Node3D
class LivingEntity extends Entity
class Player extends LivingEntity  # 3 niveles

# ‚úÖ PREFERIR: Composici√≥n
class Player extends CharacterBody3D:
    var movement_component: PlayerMovement
    var interaction_component: PlayerInteraction
    var camera_component: CameraController
```

**Por qu√©:**
- M√°s flexible (componentes intercambiables)
- M√°s testeable (componentes aislados)
- Menos acoplamiento

---

### 2. **Explicit Dependencies**

```gdscript
# ‚ùå EVITAR: Dependencias impl√≠citas
class Player:
    func _ready():
        var world = get_parent()  # ¬øQui√©n es parent?

# ‚úÖ PREFERIR: Dependencias expl√≠citas
class Player:
    @export var world: GameWorld  # Claro y verificable

    func _ready():
        assert(world != null, "Player requiere GameWorld")
```

---

### 3. **Fail Fast Principle**

```gdscript
# ‚úÖ Detectar errores temprano
func initialize(chunk_pos: Vector3i):
    if not is_inside_tree():
        push_error("CRITICAL: Chunk not in tree!")
        return

    if chunk_pos.y < 0:
        push_error("CRITICAL: Invalid chunk Y")
        return

    # Continuar solo si todo est√° OK
```

---

### 4. **Immutability Where Possible**

```gdscript
# ‚úÖ Constantes para datos que no cambian
const CHUNK_SIZE: int = 16
const MAX_WORLD_HEIGHT: int = 30

# ‚úÖ Diccionarios constantes
const BLOCK_COLORS: Dictionary = { ... }

# ‚ùå Evitar variables globales mutables sin necesidad
var global_counter: int = 0  # Dif√≠cil de rastrear cambios
```

---

### 5. **Clear API Boundaries**

```gdscript
# ‚úÖ API p√∫blica clara
class ChunkManager:
    # M√©todos p√∫blicos
    func place_block(pos: Vector3i, type: BlockType) -> bool
    func remove_block(pos: Vector3i) -> bool
    func get_block(pos: Vector3i) -> BlockType

    # M√©todos privados (prefijo _)
    func _create_chunk(pos: Vector3i) -> Chunk
    func _destroy_chunk(chunk: Chunk) -> void
```

---

## üìö REFERENCIAS Y RECURSOS

### Patrones de Dise√±o Aplicados
- **Gang of Four (GoF) Patterns:**
  - Singleton (Autoloads)
  - Observer (Signals)
  - Factory (Chunk creation)
  - Strategy (Tool behaviors)
  - State (GameState)

### Principios SOLID
- ‚úÖ **S**ingle Responsibility
- ‚úÖ **O**pen/Closed
- ‚úÖ **L**iskov Substitution
- ‚úÖ **I**nterface Segregation
- ‚úÖ **D**ependency Inversion

### Game Programming Patterns
- Spatial Partitioning (Chunks)
- Data-Driven Design (JSON-like configs)
- Object Pool (futuro)
- Dirty Flag (mesh regeneration)
- Component Pattern (Player components)

---

## üöÄ ESCALABILIDAD FUTURA

### Arquitectura para Multijugador

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  Network Layer                      ‚îÇ
‚îÇ  - NetworkManager (autoload)                        ‚îÇ
‚îÇ  - Replication de chunks                            ‚îÇ
‚îÇ  - Sync de player positions                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  Authority System                    ‚îÇ
‚îÇ  - Server = authoridad de chunks                    ‚îÇ
‚îÇ  - Clients = predicci√≥n optimista                   ‚îÇ
‚îÇ  - Rollback en caso de desync                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Arquitectura para Modding

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Mod Loader                       ‚îÇ
‚îÇ  - Lee mods desde res://mods/                      ‚îÇ
‚îÇ  - Valida scripts                                   ‚îÇ
‚îÇ  - Inyecta en puntos de extensi√≥n                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 Extension Points                     ‚îÇ
‚îÇ  - new_block_types[]                                ‚îÇ
‚îÇ  - new_tools[]                                      ‚îÇ
‚îÇ  - new_biomes[]                                     ‚îÇ
‚îÇ  - custom_structures[]                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üéØ CONCLUSIONES DE ARQUITECTURA

### Lo que funcion√≥ bien ‚úÖ

1. **Autoloads para sistemas globales**
   - F√°cil acceso sin pasar referencias
   - Inicializaci√≥n ordenada

2. **Signals para desacoplamiento**
   - Componentes independientes
   - F√°cil de extender

3. **Data-driven design**
   - Balance sin tocar c√≥digo
   - F√°cil experimentaci√≥n

4. **Chunk-based world**
   - Mundo infinito con memoria finita
   - Buena performance

5. **Separation of concerns**
   - Cada sistema tiene responsabilidad clara
   - F√°cil de mantener

### Lo que mejorar√≠a üîÑ

1. **Testing automatizado**
   - A√±adir unit tests para sistemas cr√≠ticos
   - Integration tests para generaci√≥n de mundo

2. **Dependency Injection**
   - Reducir dependencias de autoloads
   - M√°s testeable

3. **ECS (Entity Component System)**
   - Para muchas entidades (NPCs, enemigos)
   - Mejor performance con cache locality

4. **Profiling tools**
   - Monitorear performance en runtime
   - Detectar bottlenecks

5. **Documentation as code**
   - Docstrings en todas las funciones p√∫blicas
   - Generar docs autom√°ticas

---

## üìñ GLOSARIO DE ARQUITECTURA

**Autoload:** Singleton de Godot que se inicializa al inicio y persiste toda la sesi√≥n.

**Chunk:** Subdivisi√≥n espacial del mundo para optimizaci√≥n de memoria y rendering.

**Signal:** Patr√≥n Observer de Godot para comunicaci√≥n desacoplada entre nodos.

**Greedy Meshing:** Algoritmo de optimizaci√≥n que combina caras adyacentes similares.

**Spatial Partitioning:** T√©cnica de dividir espacio 3D para b√∫squedas eficientes.

**Procedural Generation:** Generaci√≥n algor√≠tmica de contenido usando semillas determin√≠sticas.

**Data-Driven Design:** Separar datos de l√≥gica para f√°cil modificaci√≥n sin recompilar.

---

**Este documento representa la experiencia arquitect√≥nica completa del proyecto.**

**Fecha:** 2025
**Versi√≥n del Proyecto:** 1.0
**Engine:** Godot 4.5.1
**Paradigma:** OOP + ECS h√≠brido
**Patrones:** 10+ patrones de dise√±o aplicados
**Principios:** SOLID + Game Programming Patterns
